<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta title="viewport" content="width=device-width, initial-scale=1.0">
    <title>Filtered Lists Display</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #333; margin-bottom: 30px; }
        .stats { display: flex; justify-content: space-around; margin-bottom: 30px; padding: 15px; background: #f8f9fa; border-radius: 5px; }
        .stat { text-align: center; }
        .stat-number { font-size: 1.5em; font-weight: bold; color: #007bff; }
        .stat-label { color: #666; font-size: 0.9em; }
        .section { margin-bottom: 30px; border: 1px solid #dee2e6; border-radius: 5px; overflow: hidden; }
        
        /* Table-like structure */
        .section-header,
        .section-stats,
        .list-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .section-header {
            background: #007bff;
            color: white;
            padding: 15px;
            font-weight: bold;
        }
        
        .section-stats {
            background: #e9ecef;
            padding: 10px 15px;
            font-size: 0.9em;
        }
        
        .list-container {
            background: #f8f9fa;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .list-item {
            padding: 8px 15px;
            border-bottom: 1px solid #dee2e6;
            font-family: monospace;
            font-size: 0.85em;
        }
        
        .list-item:nth-child(even) { background: white; }
        .list-item:hover { background: #e9ecef; }
        .list-item:last-child { border-bottom: none; }
        
        /* Column widths - consistent across header and rows */
        /* Column 1: Size */
        .section-header span:nth-child(1),
        .section-stats span:nth-child(1),
        .list-item span:nth-child(1) {
            flex: 1;
            flex-shrink: 0;
            text-align: right;
            font-family: monospace;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* Column 2: Page Name */
        .section-header span:nth-child(2),
        .section-stats span:nth-child(2),
        .list-item span:nth-child(2),
        .section-header span:nth-child(4),
        .section-stats span:nth-child(4),
        .list-item span:nth-child(4) {
            flex: 5;
            min-width: 0;
        }
        
        /* Column 3: isOnCommons */
        .section-header span:nth-child(3),
        .section-stats span:nth-child(3),
        .list-item span:nth-child(3) {
            flex: 1;
            flex-shrink: 0;
            text-align: center;
        }
        
        
        /* Specific styling for header columns */
        .col-title {
            font-weight: bold;
        }
        
        .isOnCommons {
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .check-existence-btn {
            background: white;
            color: #007bff;
            border: 1px solid white;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85em;
            white-space: nowrap;
        }
        
        .check-existence-btn:hover {
            background: #f0f0f0;
        }
        
        .check-existence-btn:disabled {
            cursor: wait;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .error { background: #f8d7da; color: #721c24; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .loading { text-align: center; padding: 50px; color: #666; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Filtered Lists from Lingua Libre Namespaces</h1>
        
        <div style="text-align: center; margin-bottom: 20px;">
            <button id="open-namespace-manager" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1em;">
                ðŸ“Š Manage Namespace Data
            </button>
        </div>
        
        <div id="loading" class="loading">Loading data...</div>
        
        <div id="content" style="display: none;">
            <div class="stats">
                <div class="stat">
                    <div class="stat-number" id="total-original">0</div>
                    <div class="stat-label">Total Original</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="total-removed">0</div>
                    <div class="stat-label">Total Filtered Out</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="total-filtered">0</div>
                    <div class="stat-label">Total Kept</div>
                </div>
            </div>
            
            <div id="sections-container">
                <!-- Sections will be populated here -->
            </div>
        </div>
    </div>

    <!-- Load all JS files -->
    <script src="js/listing.js"></script>
    <script src="js/user.js"></script>
    <script src="js/help.js"></script>
    <script src="js/lingualibre.js"></script>
    <script src="js/template.js"></script>
    <script src="js/list.js"></script>
    <script src="js/category.js"></script>
    <script src="js/translations.js"></script>

    <script>
        // Load rename rules from replaces.json
        let renameRules = [];
        fetch('./json/replaces.json')
            .then(response => response.json())
            .then(data => {
                renameRules = data.rules.filter(rule => rule.type === 'rename');
                console.log(`âœ… Loaded ${renameRules.length} rename rules from replaces.json`);
            })
            .catch(error => {
                console.error('âŒ Error loading replaces.json:', error);
            });

        // Apply rename transformations to a page title
        function applyRenameTransformations(pageTitle) {
            let transformed = pageTitle;
            
            for (const rule of renameRules) {
                try {
                    const regex = new RegExp(rule.match, 'g');
                    transformed = transformed.replace(regex, rule.replace);
                } catch (error) {
                    console.error(`Error applying rename rule:`, rule, error);
                }
            }
            
            return transformed;
        }

        // Page existence checker with caching and throttling
        const PageExistenceChecker = {
            cache: new Map(),
            queue: [],
            isProcessing: false,
            batchSize: 50, // Check 50 pages per API call
            delayBetweenBatches: 1000, // 1 second between batches
            
            // Check if a page exists (returns promise)
            async check(pageTitle) {
                // Return cached result if available
                if (this.cache.has(pageTitle)) {
                    return this.cache.get(pageTitle);
                }
                
                // Add to queue and process
                return new Promise((resolve) => {
                    this.queue.push({ pageTitle, resolve });
                    this.processBatch();
                });
            },
            
            // Process queued requests in batches
            async processBatch() {
                if (this.isProcessing || this.queue.length === 0) {
                    return;
                }
                
                this.isProcessing = true;
                
                // Take a batch from the queue
                const batch = this.queue.splice(0, this.batchSize);
                const titles = batch.map(item => item.pageTitle);
                
                try {
                    // Make API request for the batch
                    const results = await this.queryAPI(titles);
                    
                    // Resolve all promises in the batch
                    batch.forEach(item => {
                        const exists = results[item.pageTitle] || false;
                        this.cache.set(item.pageTitle, exists);
                        item.resolve(exists);
                    });
                } catch (error) {
                    console.error('Error checking page existence:', error);
                    // On error, resolve all as false
                    batch.forEach(item => {
                        this.cache.set(item.pageTitle, false);
                        item.resolve(false);
                    });
                }
                
                this.isProcessing = false;
                
                // If there are more items in queue, process them after delay
                if (this.queue.length > 0) {
                    setTimeout(() => this.processBatch(), this.delayBetweenBatches);
                }
            },
            
            // Query the MediaWiki API
            async queryAPI(titles) {
                // Apply rename transformations to all titles
                const transformedTitles = titles.map(title => applyRenameTransformations(title));
                
                console.log('Original titles:', titles);
                console.log('Transformed titles:', transformedTitles);
                
                const url = new URL('https://commons.wikimedia.org/w/api.php');
                url.searchParams.set('action', 'query');
                url.searchParams.set('format', 'json');
                url.searchParams.set('origin', '*');
                url.searchParams.set('titles', transformedTitles.join('|'));
                url.searchParams.set('prop', 'info');
                
                const response = await fetch(url);
                const data = await response.json();
                
                const results = {};
                
                if (data.query && data.query.pages) {
                    // Map results back to original titles
                    const transformedToOriginal = {};
                    titles.forEach((original, index) => {
                        transformedToOriginal[transformedTitles[index]] = original;
                    });
                    
                    for (const pageId in data.query.pages) {
                        const page = data.query.pages[pageId];
                        const originalTitle = transformedToOriginal[page.title] || page.title;
                        // Page exists if pageId is not negative
                        results[originalTitle] = parseInt(pageId) > 0;
                    }
                }
                
                return results;
            },
            
            // Synchronous version that returns cached value or '?' for pending
            checkSync(pageTitle) {
                if (this.cache.has(pageTitle)) {
                    return this.cache.get(pageTitle);
                }
                // Trigger async check
                this.check(pageTitle);
                return null; // Unknown, check in progress
            }
        };

        // Page size checker for LinguaLibre.org
        const PageSizeChecker = {
            cache: new Map(),
            queue: [],
            isProcessing: false,
            batchSize: 50,
            delayBetweenBatches: 1000,
            
            async check(pageTitle) {
                if (this.cache.has(pageTitle)) {
                    return this.cache.get(pageTitle);
                }
                
                return new Promise((resolve) => {
                    this.queue.push({ pageTitle, resolve });
                    this.processBatch();
                });
            },
            
            async processBatch() {
                if (this.isProcessing || this.queue.length === 0) {
                    return;
                }
                
                this.isProcessing = true;
                const batch = this.queue.splice(0, this.batchSize);
                const titles = batch.map(item => item.pageTitle);
                
                try {
                    const results = await this.queryAPI(titles);
                    
                    batch.forEach(item => {
                        const size = results[item.pageTitle] || 0;
                        this.cache.set(item.pageTitle, size);
                        item.resolve(size);
                    });
                } catch (error) {
                    console.error('Error checking page size:', error);
                    batch.forEach(item => {
                        this.cache.set(item.pageTitle, 0);
                        item.resolve(0);
                    });
                }
                
                this.isProcessing = false;
                
                if (this.queue.length > 0) {
                    setTimeout(() => this.processBatch(), this.delayBetweenBatches);
                }
            },
            
            async queryAPI(titles) {
                const url = new URL('https://lingualibre.org/api.php');
                url.searchParams.set('action', 'query');
                url.searchParams.set('format', 'json');
                url.searchParams.set('origin', '*');
                url.searchParams.set('titles', titles.join('|'));
                url.searchParams.set('prop', 'info');
                
                const response = await fetch(url);
                const data = await response.json();
                
                const results = {};
                
                if (data.query && data.query.pages) {
                    for (const pageId in data.query.pages) {
                        const page = data.query.pages[pageId];
                        // Get page length (size in bytes)
                        results[page.title] = page.length || 0;
                    }
                }
                
                return results;
            },
            
            checkSync(pageTitle) {
                if (this.cache.has(pageTitle)) {
                    return this.cache.get(pageTitle);
                }
                this.check(pageTitle);
                return null;
            },
            
            formatSize(bytes) {
                if (bytes === null || bytes === 0) return '-';
                if (bytes < 1024) return `${bytes}B`;
                if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}K`;
                return `${(bytes / (1024 * 1024)).toFixed(1)}M`;
            }
        };
        
        // Wrapper function for ease of use
        function existsOnWiki(pageTitle) {
            const result = PageExistenceChecker.checkSync(pageTitle);
            if (result === null) {
                return 'â³'; // Pending/checking
            }
            return result;
        }
        
        // Configuration for namespace files
        const NAMESPACE_CONFIG = [
            { ns: 'user', title: 'User:*' },
            { ns: 'help', title: 'Help:*' },
            { ns: 'lingualibre', title: 'LinguaLibre:*' },
            { ns: 'list', title: 'List:*' },
            { ns: 'category', title: 'Category:*' },
            { ns: 'template', title: 'Template:*' },
            { ns: 'translations', title: 'Translations:*' },
            { ns: 'translations_root', title: 'Translations:* roots' },
        ];

        // DRY: Function to prepare root namespaces from their full counterparts
        function prepareRootNamespace(sourceNamespace) {
            if (!window[sourceNamespace] || !Array.isArray(window[sourceNamespace].list)) {
                console.warn(`Cannot prepare root for ${sourceNamespace}: source not found`);
                return null;
            }
            
            return {
                cleaner: window[sourceNamespace].cleaner,
                list: [...new Set(window[sourceNamespace].list.map(item => item.split('/')[0]))]
            };
        }

        // Initialize root namespaces
        function initializeRootNamespaces() {            
            const translationsRoot = prepareRootNamespace('translations');
            if (translationsRoot) {
                window.translations_root = translationsRoot;
                console.log(`âœ… Initialized translations_root with ${translationsRoot.list.length} items`);
            }
        }

        // Call on initial load
        initializeRootNamespaces();
        
        // Expose globally so listing.js can call it after updating data
        window.initializeRootNamespaces = initializeRootNamespaces;

        // Safe cleaner function wrapper
        function safeCleaner(inputList, cleanerFunction) {
            try {
                if (typeof cleanerFunction !== 'function') {
                    console.warn('Cleaner is not a function, returning original list');
                    return inputList;
                }
                
                const result = cleanerFunction(inputList);
                
                if (!Array.isArray(result)) {
                    console.warn('Cleaner function did not return an array, returning original list');
                    return inputList;
                }
                
                return result;
            } catch (error) {
                console.error('Error in cleaner function:', error);
                return inputList;
            }
        }

        // Create section HTML
        function createSection(title, originalCount, filteredCount, filteredItems) {
            const removedCount = originalCount - filteredCount;
            const removalPercentage = originalCount > 0 ? ((removedCount / originalCount) * 100).toFixed(1) : 0;
            const sectionId = `section-${title.replace(/[^a-zA-Z0-9]/g, '-')}`;
            
            return `
                <div class="section" id="${sectionId}">
                    <div class="section-header">
                        <span class="col-title">Size</span>
                        <span class="pageName col-title">${title}</span>
                        <span class="isOnCommons col-title">
                            <button class="check-existence-btn" data-section="${sectionId}">
                                <img src="./assets/commons.svg" alt="Check WC" style="width:16px;height:16px;"/>?
                            </button>
                        </span>
                        <span class="col-title">Status</span>
                    </div>
                    <div class="section-stats">
                        <span></span>
                        <span>Original: ${originalCount} | Filtered: ${removedCount} | Kept: ${filteredCount}</span>
                        <span style="opacity: 0.8;">
                            ${removalPercentage}% out
                        </span>
                        <span></span>
                    </div>
                    <div class="list-container">
                        ${filteredItems.length > 0 
                            ? filteredItems.map(item => {
                                const transformedTitle = applyRenameTransformations(item);
                                return `
                                <div class="list-item" data-page-lingualibre="${item}" data-page-commons="${transformedTitle}">
                                    <span class="pageSize">-</span>
                                    <span class="pageTitle"><a href="https://lingualibre.org/wiki/${item}">${item}</a></span>
                                    <span class="isOnCommons">-</span>
                                    <span class="pageTitle"><a href="https://commons.wikimedia.org/wiki/${transformedTitle}">${transformedTitle}</a></span>
                                </div>`;
                            }).join('')
                            : '<div class="list-item" style="font-style: italic; color: #666;"><span></span><span>No items remaining after filtering</span><span></span><span></span></div>'
                        }
                    </div>
                </div>
            `;
        }
        
        // Update existence indicators for a specific section
        async function updateSectionExistence(sectionId) {
            const section = document.getElementById(sectionId);
            if (!section) return;
            
            const button = section.querySelector('.check-existence-btn');
            const listItems = section.querySelectorAll('.list-item[data-page-lingualibre]');
            
            if (!listItems.length) return;
            
            // Update button state
            button.disabled = true;
            var commonsButton = `<img src="./assets/commons.svg" alt="Checking..." style="width:16px;height:16px;"/><strong>?</strong>`;
            button.innerHTML = commonsButton;
            button.style.cursor = 'wait';
            
            const totalCount = listItems.length;
            let checkedCount = 0;
            
            // Set all to pending immediately
            listItems.forEach(listItem => {
                const existenceIndicator = listItem.querySelector('.isOnCommons');
                const sizeIndicator = listItem.querySelector('.pageSize');
                if (existenceIndicator) existenceIndicator.textContent = 'â³';
                if (sizeIndicator) sizeIndicator.textContent = 'â³';
            });
            
            // Queue all checks at once (this triggers batch processing)
            const checkPromises = Array.from(listItems).map(async (listItem) => {
                const pageTitle = listItem.getAttribute('data-page-lingualibre');
                const commonsTitle = listItem.getAttribute('data-page-commons');
                
                if (pageTitle && commonsTitle) {
                    const existenceIndicator = listItem.querySelector('.isOnCommons');
                    const sizeIndicator = listItem.querySelector('.pageSize');
                    
                    // Check Commons existence with transformed title, and LinguaLibre size with original title
                    const [exists, size] = await Promise.all([
                        PageExistenceChecker.check(pageTitle), // This will use transformed title internally
                        PageSizeChecker.check(pageTitle)
                    ]);
                    
                    if (existenceIndicator) existenceIndicator.textContent = exists ? 'âœ…' : 'âŒ';
                    if (sizeIndicator) sizeIndicator.textContent = PageSizeChecker.formatSize(size);
                    
                    checkedCount++;
                    button.textContent = `${checkedCount}/${totalCount}`;
                }
            });
            
            // Wait for all checks to complete
            await Promise.all(checkPromises);
            
            // Update button to show completion
            button.innerHTML = commonsButton; 
            button.style.background = '#28a745';
            button.style.color = 'white';
            button.style.borderColor = '#28a745';
        }
        
        // Update existence indicators asynchronously
        async function updateExistenceIndicators() {
            const listItems = document.querySelectorAll('.list-item[data-page-lingualibre]');
            
            for (const listItem of listItems) {
                const pageTitle = listItem.getAttribute('data-page-lingualibre');
                const commonsTitle = listItem.getAttribute('data-page-commons');
                
                if (pageTitle && commonsTitle) {
                    const indicator = listItem.querySelector('.isOnCommons');
                    if (indicator) {
                        // Check existence (this will use cache or queue the request)
                        const exists = await PageExistenceChecker.check(pageTitle);
                        indicator.textContent = exists ? 'âœ…' : 'âŒ';
                    }
                }
            }
        }

        // Process namespace data
        function processNamespace(config) {
            // Get data object from window
            const dataObj = window[config.ns];
            
            if (!dataObj) {
                console.warn(`${config.title}: Data object not found`);
                return null;
            }
            
            if (!Array.isArray(dataObj.list)) {
                console.warn(`${config.title}: Invalid or missing list array`);
                return null;
            }
            
            if (typeof dataObj.cleaner !== 'function') {
                console.warn(`${config.title}: Invalid or missing cleaner function`);
                return null;
            }
            
            const originalList = dataObj.list;
            const filteredList = safeCleaner(originalList, dataObj.cleaner);
            
            return {
                title: config.title,
                original: originalList.length,
                filtered: filteredList,
                filteredCount: filteredList.length
            };
        }

        // Main processing function
        function processData() {
            try {
                const sections = [];
                let totalOriginal = 0;
                let totalFiltered = 0;

                // Process each namespace
                for (const config of NAMESPACE_CONFIG) {
                    const sectionData = processNamespace(config);
                    if (sectionData) {
                        sections.push(sectionData);
                        totalOriginal += sectionData.original;
                        totalFiltered += sectionData.filteredCount;
                    }
                }

                if (sections.length === 0) {
                    throw new Error('No valid namespace data found');
                }

                // Update totals
                document.getElementById('total-original').textContent = totalOriginal;
                document.getElementById('total-filtered').textContent = totalFiltered;
                document.getElementById('total-removed').textContent = totalOriginal - totalFiltered;

                // Create sections
                const sectionsContainer = document.getElementById('sections-container');
                sectionsContainer.innerHTML = sections.map(section => 
                    createSection(section.title, section.original, section.filteredCount, section.filtered)
                ).join('');

                // Show content
                document.getElementById('loading').style.display = 'none';
                document.getElementById('content').style.display = 'block';

                // Add event listeners to check buttons
                document.querySelectorAll('.check-existence-btn').forEach(button => {
                    button.addEventListener('click', function() {
                        const sectionId = this.getAttribute('data-section');
                        updateSectionExistence(sectionId);
                    });
                });

                // Log summary
                console.log('Processing complete:', {
                    sectionsProcessed: sections.length,
                    totalOriginal,
                    totalFiltered,
                    totalRemoved: totalOriginal - totalFiltered,
                    sections: sections.map(s => ({ title: s.title, original: s.original, filtered: s.filteredCount }))
                });

            } catch (error) {
                console.error('Error processing data:', error);
                document.getElementById('loading').innerHTML = 
                    `<div class="error">Error loading data: ${error.message}<br>Check console for details.</div>`;
            }
        }
        
        // Expose processData globally so it can be called from listing.js
        window.processData = processData;

        // Start processing when page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Small delay to ensure all scripts are fully loaded
            setTimeout(processData, 100);
            
            // Connect the namespace manager button
            const namespaceBtn = document.getElementById('open-namespace-manager');
            if (namespaceBtn && typeof window.openNamespaceManager === 'function') {
                namespaceBtn.addEventListener('click', window.openNamespaceManager);
            }
        });
    </script>
</body>
</html>
